[
  {
    "name": "c-code-next-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "critters",
      "date-fns",
      "framer-motion",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "swc",
      "swr",
      "tailwind",
      "typescript",
      "vaul",
      "wrangler",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection Guidelines\n\nThis template offers a streamlined and performant foundation for building beautiful, responsive landing pages with modern animations and iconography.\n\n* Use this template when you need:\n  * High-performance server-side heavy projects and dashboards\n  * Pages optimized for SEO with server-rendered content\n  * Responsive design with smooth scrolling and page transitions\n  * Easily customizable layouts for product launches, waitlists, or portfolios\n  * Design-first experiences with animation and interactivity\n\n* Do not use it for:\n  * Lightweight, mostly client side heavy projects\n  * Static pages\n\n* Built with:\n  * **Next.js (Page Router)** for hybrid static & server rendering, built-in SEO, and routing\n  * **Tailwind CSS** for rapid UI development with utility-first styling\n  * **Lucide Icons** for sleek, consistent iconography\n  * **Framer Motion** for intuitive, production-ready animations\n  * **TypeScript** and **ESLint** for type safety and code quality",
      "usage": "# Usage instructions\n\nYou can start editing the page by modifying `pages/index.tsx`. The page auto-updates as you edit the file.\n\nAPI routes can be accessed on [http://localhost:3000/api/hello](http://localhost:3000/api/hello). This endpoint can be edited in `pages/api/hello.ts`.\n\nThe `pages/api` directory is mapped to `/api/*`. Files in this directory are treated as API routes instead of React pages.\n\n- Built with:\n  * Next.js (Page Router) for hybrid static/server rendering and SEO optimization\n  * Tailwind CSS** for utility-first styling and rapid prototyping\n  * Lucide Icons** (React) for modern, consistent iconography\n  * Framer Motion** for smooth, production-ready animations\n  * ESLint and TypeScript for linting and type safety out of the box\n  * ShadCN UI** (v2.3.0) for customizable and accessible UI components built on Radix UI primitives\n\n- Restrictions:\n  * When including `tailwind.config.js`, **hardcode custom colors** directly in the config file – do **not** define them in `globals.css` unless specified\n  * Next.js cannot infer props for React Components, so YOU MUST provide default props\n  * Use Page router and not App router\n\n- Styling:\n  * Must generate **fully responsive** and accessible layouts\n  * Use Shadcn preinstalled components rather than writing custom ones when possible\n  * Use **Tailwind's spacing, layout, and typography utilities** for all components\n\n- Components:\n  * All Shadcn components are available and can be imported from @/components/ui/...\n  * Do not write custom components if shadcn components are available\n  * Icons from Lucide should be imported directly from `lucide-react`\n\n- Animation:\n  * Use `framer-motion`'s `motion` components to animate sections on scroll or page load\n  * You can integrate variants and transitions using Tailwind utility classes alongside motion props\n\n---\n\nComponents available:\n```sh\n$ ls -1 src/components/ui\naccordion.tsx\nalert-dialog.tsx\nalert.tsx\naspect-ratio.tsx\navatar.tsx\nbadge.tsx\nbreadcrumb.tsx\nbutton.tsx\ncalendar.tsx\ncard.tsx\ncarousel.tsx\nchart.tsx\ncheckbox.tsx\ncollapsible.tsx\ncommand.tsx\ncontext-menu.tsx\ndialog.tsx\ndrawer.tsx\ndropdown-menu.tsx\nform.tsx\nhover-card.tsx\ninput-otp.tsx\ninput.tsx\nlabel.tsx\nmenubar.tsx\nnavigation-menu.tsx\npagination.tsx\npopover.tsx\nprogress.tsx\nradio-group.tsx\nresizable.tsx\nscroll-area.tsx\nselect.tsx\nseparator.tsx\nsheet.tsx\nsidebar.tsx\nskeleton.tsx\nslider.tsx\nsonner.tsx\nswitch.tsx\ntable.tsx\ntabs.tsx\ntextarea.tsx\ntoast.tsx\ntoggle-group.tsx\ntoggle.tsx\ntooltip.tsx\n```\n\n### Usage Example\n\n```tsx file=\"src/components/Hero.tsx\"\n'use client'\n\nimport { motion } from 'framer-motion'\nimport { ArrowRightIcon } from 'lucide-react'\nimport { Button } from '@/components/ui/button'\n\nexport function Hero() {\n  return (\n    <section className=\"w-full bg-white py-20 text-center\">\n      <motion.div \n        initial={{ opacity: 0, y: 30 }} \n        animate={{ opacity: 1, y: 0 }} \n        transition={{ duration: 0.6 }}\n        className=\"mx-auto max-w-2xl px-6\"\n      >\n        <h1 className=\"text-4xl font-bold tracking-tight sm:text-5xl\">\n          Build Stunning Landing Pages Fast\n        </h1>\n        <p className=\"mt-4 text-gray-600\">\n          A modern Next.js starter with Tailwind, Framer Motion, and Lucide.\n        </p>\n        <div className=\"mt-6 flex justify-center\">\n          <Button className=\"inline-flex items-center gap-2 rounded-md bg-black px-6 py-3 text-white hover:bg-gray-900 transition\">\n            Get Started\n            <ArrowRightIcon className=\"size-4\" />\n          </Button>\n        </div>\n      </motion.div>\n    </section>\n  )\n}\n```"
    }
  },
  {
    "name": "c-code-react-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "framer-motion",
      "hono",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "wrangler",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nModern React SPA starter\n\nUse when:\n- Client-side only apps with no backend persistence\n- Static apps, dashboards\n- Simple, fast Vite projects\n\nAvoid when:\n- SEO/SSR landing pages\n- Heavy backend/server needs\n- Data persistence of any kind is required on server side\n\nBuilt with:\n- React Router, ShadCN UI, Tailwind, Lucide Icons, ESLint, Vite",
      "usage": "# Usage\n\n## Built with\n- React Router 6, ShadCN UI, Tailwind, Lucide Icons, ESLint, Vite\n- Platform-agnostic backend support (can be deployed to Cloudflare Workers, Google App Engine, or any hosting platform)\n\n## Restrictions\n- Tailwind: define custom colors in `tailwind.config.js` (not in `index.css`)\n\n## Styling\n- Responsive, accessible\n- Prefer ShadCN components; Tailwind utilities for custom parts\n- Icons from `lucide-react`\n- Error boundaries are already implemented\n\n## Animation\n- Use `framer-motion` for small interactions when needed\n\n## Components\n- Import from `@/components/ui/*` (ShadCN). Avoid reinventing components.\n\n## Example\n```tsx\nimport { Button } from '@/components/ui/button'\nimport { Card, CardContent } from '@/components/ui/card'\n\nexport function Example() {\n  return (\n    <Card className=\"max-w-sm\">\n      <CardContent className=\"p-4 flex gap-2\">\n        <Button>Click</Button>\n      </CardContent>\n    </Card>\n  )\n}\n```\n\n## Backend (optional)\n- If you add backend routes, do it in `worker/index.ts` (or your platform's entry point). Follow the existing pattern carefully to avoid breakage.\n- The backend can be deployed to Cloudflare Workers, Google App Engine, or any Node.js-compatible hosting platform."
    }
  },
  {
    "name": "vite-cf-DO-KV-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "framer-motion",
      "hono",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "wrangler",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nFull-stack template with a seeded datastore for multi-entity demos. Ships with Firestore (via REST) as the default provider plus an HTTP fallback, so the same generated backend can deploy to Google App Engine, Cloudflare Workers, or any hosting platform that can supply environment variables.\n\nUse when:\n- You want built-in seed endpoints to bootstrap demo content\n- The backend needs CRUD APIs plus counters/stateful metrics\n- You prefer Firestore defaults but may swap to another HTTPS provider later\n\nAvoid when:\n- You only need a frontend SPA with no backend\n- SEO/SSR marketing sites (choose Next.js template)\n\nBuilt with:\n- React Router, ShadCN UI, Tailwind, Lucide Icons, ESLint, Vite\n- Hono API + datastore abstraction (Firestore default, HTTP provider optional)",
      "usage": "# Usage\n\n## Overview\nFull-stack React + Hono template with a seeded datastore abstraction. Defaults to Google Cloud Firestore (REST) but can swap to any HTTPS-accessible provider through environment variables.\n- Frontend: React Router 6 + TypeScript + ShadCN UI\n- Backend: Hono APIs using `createDataStore` helpers (Firestore by default, HTTP fallback)\n- Shared: Types in `shared/types.ts`\n- Deployment: Works on Google App Engine, Cloudflare Workers, or any hosting platform that can supply the env vars\n\n## ⚠️ IMPORTANT: Demo Content\n**All demo pages, mock data, and API endpoints exist purely for reference. Replace them with real application logic.**\n- Replace `HomePage.tsx` / `DemoPage.tsx` with production UI\n- Swap out mock data in `shared/mock-data.ts`\n- Update demo API routes in `worker/userRoutes.ts` and `worker/entities.ts`\n\n## Tech Stack\n- React Router 6, ShadCN UI, Tailwind, Lucide, Hono, TypeScript\n\n## Development Guidelines\n- **Tailwind Colors**: Extend `tailwind.config.js`; avoid hardcoding in CSS\n- **Components**: Prefer existing ShadCN components\n- **Icons**: Import from `lucide-react`\n- **Error Handling**: Error boundaries are pre-implemented\n- **Backend Patterns**: Follow `worker/index.ts` + `worker/userRoutes.ts` and rely on datastore helpers\n- **Platform Config**: Keep deployment descriptors (e.g., `wrangler.jsonc`, `app.yaml`) intact unless explicitly required\n\n## Code Organization\n\n### Frontend\n- `src/pages/HomePage.tsx` – placeholder landing page\n- `src/pages/DemoPage.tsx` – demo UI for seed data + counters\n- `src/components/ThemeToggle.tsx` – theme switcher\n- `src/hooks/useTheme.ts` – theme management hook\n\n### Backend\n- `worker/index.ts` – backend entrypoint (middleware + router)\n- `worker/userRoutes.ts` – API routes (seed, CRUD, counter)\n- `worker/entities.ts` – datastore helpers (seed logic, CRUD, counters)\n- `worker/core-utils.ts` – datastore factory + response utilities\n- `worker/datastore/*` – Firestore + HTTP provider implementations\n\n### Shared\n- `shared/types.ts` – shared DTOs for API responses\n- `shared/mock-data.ts` – demo seed data\n\n## API Patterns\nUse `createDataStore` helpers instead of platform-specific bindings:\n```ts\nimport { createDataStore, ok, bad } from './core-utils';\n\napp.get('/api/items', async (c) => {\n  const store = createDataStore(c.env);\n  const page = await store.list<Item>('items', { limit: 25 });\n  return ok(c, page);\n});\n\napp.post('/api/items', async (c) => {\n  const payload = (await c.req.json()) as Partial<Item>;\n  if (!payload.name?.trim()) return bad(c, 'name required');\n  const store = createDataStore(c.env);\n  const next = await store.create('items', { ...payload, id: crypto.randomUUID() });\n  return ok(c, next);\n});\n```\n\n## Environment Variables\nConfigure datastore credentials once secrets are provisioned:\n- `FIRESTORE_PROJECT_ID` – GCP project ID\n- `FIRESTORE_CLIENT_EMAIL` – service account email\n- `FIRESTORE_PRIVATE_KEY_B64` – base64 encoded private key (PEM)\n- Optional: `FIRESTORE_DATABASE_ID`, `FIRESTORE_API_ENDPOINT`\n- Switch providers by setting `DATA_PROVIDER=http` and supplying:\n  - `DATA_HTTP_BASE_URL`\n  - `DATA_HTTP_API_KEY` (optional)\n  - `DATA_HTTP_HEADERS_JSON` (optional additional headers)\n\n## Seeding & Counters\n- `/api/seed` triggers `ensureSeed` in `worker/entities.ts`, inserting mock data and a counter record if none exist.\n- Update or remove this endpoint for production once you have real migrations.\n\n## Storage Patterns\n- Use descriptive collection names (`demo-items`, `counters`, etc.) via datastore helpers.\n- Prefer idempotent operations (e.g., upsert) and partial updates (`store.update`) for mutable records.\n\n## Frontend\n- Call `/api/*` endpoints directly\n- Handle loading/error states using shared types"
    }
  },
  {
    "name": "vite-cf-DO-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "framer-motion",
      "hono",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nFull-stack application with server-side state management. Minimal setup that uses a global state store for persistence and stateful features.\n\nUse when:\n- You need a backend with persistent storage using Firestore (default) or any HTTPS data provider\n- Real-time/stateful services, dashboards, counters\n- Backend-heavy apps requiring persistent state without locking into Cloudflare primitives\n\nAvoid when:\n- Static/SPAs with no backend\n- SEO/SSR landing pages\n- You only need database-like storage across many entities (see Firestore chat runner)\n\nBuilt with:\n- React Router, ShadCN UI, Tailwind, Lucide Icons, ESLint, Vite\n- Platform-agnostic backend powered by a datastore abstraction (Firestore default, HTTP fallback) that can deploy to Google App Engine, Cloudflare Workers, or any hosting platform",
      "usage": "# Usage\n\n## Overview\nFull-stack React application with server-side state management powered by a provider-agnostic datastore abstraction.\n- Frontend: React Router 6 + TypeScript + ShadCN UI\n- Backend: Hono-based API using `createDataStore` (Firestore default, HTTP fallback)\n- Shared: Types in `shared/types.ts`\n- Deployment: Works on Google App Engine, Cloudflare Workers, or any hosting platform\n\n## ⚠️ IMPORTANT: Demo Content\n**All demo pages, mock data, and API endpoints exist only to showcase patterns. Replace them with real application logic.**\n- Replace `HomePage.tsx` and `DemoPage.tsx` with actual pages\n- Remove or adapt mock data in `shared/mock-data.ts`\n- Replace demo API endpoints (`/api/demo`, `/api/counter`) with real functionality backed by your datastore\n\n## Tech Stack\n- React Router 6, ShadCN UI, Tailwind, Lucide, Hono, TypeScript\n\n## Development Guidelines\n- **Tailwind Colors**: Extend `tailwind.config.js`; do not hardcode colors in CSS\n- **Components**: Prefer existing ShadCN components over custom implementations\n- **Icons**: Import from `lucide-react`\n- **Error Handling**: Error boundaries are provided; wire them into your flows\n- **Backend Patterns**: Follow `worker/index.ts` and `worker/userRoutes.ts`, using `createDataStore` for persistence\n- **Platform Config**: Keep deployment descriptors (e.g., `wrangler.jsonc`, `app.yaml`) intact unless absolutely required\n\n## Styling\n- Responsive, accessible layouts\n- Use Tailwind for spacing/typography and ShadCN for components\n\n## Code Organization\n\n### Frontend\n- `src/pages/HomePage.tsx` – placeholder landing page\n- `src/pages/DemoPage.tsx` – demo of datastore-backed endpoints\n- `src/components/ThemeToggle.tsx` – theme switcher\n- `src/hooks/useTheme.ts` – theme management hook\n\n### Backend\n- `worker/index.ts` – backend entrypoint (middleware + router wiring)\n- `worker/userRoutes.ts` – API routes; use datastore helpers instead of platform-specific APIs\n- `worker/entities.ts` – demo persistence helpers built on `createDataStore`\n- `worker/core-utils.ts` – datastore factory and response helpers\n- `worker/datastore/*` – Firestore + HTTP provider implementations\n\n### Shared\n- `shared/types.ts` – API/data types\n- `shared/mock-data.ts` – demo-only seed data\n\n## API Patterns\nUse the datastore abstraction rather than platform-specific bindings:\n```ts\nimport { createDataStore, ok, bad } from './core-utils';\n\napp.get('/api/my-data', async (c) => {\n  const store = createDataStore(c.env);\n  const page = await store.list<MyType>('my-data');\n  return ok(c, page.items);\n});\n\napp.post('/api/my-data', async (c) => {\n  const payload = (await c.req.json()) as MyType;\n  if (!payload.name?.trim()) return bad(c, 'name required');\n  const store = createDataStore(c.env);\n  await store.create('my-data', payload, { id: payload.id ?? crypto.randomUUID() });\n  return ok(c, payload);\n});\n```\n\n## Environment Variables\nConfigure datastore credentials via environment variables or secrets:\n- `FIRESTORE_PROJECT_ID` – GCP project ID\n- `FIRESTORE_CLIENT_EMAIL` – service account email\n- `FIRESTORE_PRIVATE_KEY_B64` – base64-encoded private key (PEM)\n- Optional: `FIRESTORE_DATABASE_ID`, `FIRESTORE_API_ENDPOINT`\n- `DATA_PROVIDER` – set to `http` to switch away from Firestore\n- `DATA_HTTP_BASE_URL`, `DATA_HTTP_API_KEY`, `DATA_HTTP_HEADERS_JSON` – configure external HTTPS datastore\n\n## Storage Patterns\n- Use descriptive collection names (`demo-items`, `counters`, etc.)\n- Seed default data through helpers (see `ensureDemoSeed`)\n- Prefer idempotent operations and partial updates via `store.update`\n\n## Frontend\n- Call `/api/*` routes directly\n- Handle loading and error states using shared types"
    }
  },
  {
    "name": "vite-cf-DO-v2-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "framer-motion",
      "hono",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nGeneral-purpose full-stack application template with Google Cloud Firestore as the default data store. The backend exposes a storage abstraction that can point to Firestore or any HTTPS-accessible database (e.g., MongoDB Data API) via environment configuration.\n\nUse when:\n- Backend-heavy apps with multiple entities and server-side persistence\n- Chats, ecommerce, dashboards\n- Cost-effective persistence\n- General purpose storage for any multi-entity data\n\nAvoid when:\n- Static/SPAs with no backend\n- SEO/SSR landing pages\n- You need direct access to platform-specific features\n\nNote: Defaults to Google Cloud (App Engine + Firestore) but remains platform-agnostic. Swap providers (e.g., MongoDB) by supplying HTTPS credentials via environment variables.\n\nBuilt with:\n- React Router, ShadCN UI, Tailwind, Lucide Icons, ESLint, Vite\n- Backend data layer with pluggable providers (`firestore` by default, `http` proxy for others)\n- Works on Cloudflare Workers, Google App Engine, or any hosting platform that can expose the same environment variables",
      "usage": "# Usage\n\n## Overview\nFull-stack React + Hono starter wired for Google Cloud App Engine with Firestore by default. The backend exposes a pluggable data store so you can swap Firestore for any HTTPS-accessible database (MongoDB Data API, Supabase REST, custom microservice) by flipping environment variables.\n\n- **Frontend**: React Router 6, ShadCN UI, Tailwind, TypeScript\n- **Backend**: Hono API running on Cloudflare Workers or App Engine Node\n- **Storage**: Firestore REST integration (default) + HTTP proxy provider\n- **Shared**: Types in `shared/types.ts`\n\n## Important: Demo Content\nThe bundled pages, mock data, and routes are for reference only.\n- Replace `HomePage.tsx` / `DemoPage.tsx` with real UI\n- Swap out `shared/mock-data.ts` with production data structures\n- Replace demo API routes in `worker/user-routes.ts`\n\n## Architecture\n- `worker/core-utils.ts` & `worker/datastore/*`: storage configuration + provider implementations\n- `worker/entities.ts`: example repositories (users, chats) using the data store abstraction\n- `worker/user-routes.ts`: demo API routes (CRUD + messaging)\n- `src/lib/api-client.ts`: React Query client\n\n## Environment Variables\nSet these before deploying (Cloudflare secrets or App Engine env vars):\n\n### Firestore (default)\n- `DATA_PROVIDER=firestore`\n- `FIRESTORE_PROJECT_ID` – GCP project ID\n- `FIRESTORE_CLIENT_EMAIL` – service-account email\n- `FIRESTORE_PRIVATE_KEY_B64` – base64-encoded PEM private key (entire key file encoded once)\n- `FIRESTORE_DATABASE_ID` *(optional)* – defaults to `(default)`\n- `FIRESTORE_API_ENDPOINT` *(optional)* – override for emulator testing\n\n### HTTP provider (e.g., MongoDB Data API)\nSet `DATA_PROVIDER=http` and supply:\n- `DATA_HTTP_BASE_URL` – HTTPS endpoint exposing CRUD routes\n- `DATA_HTTP_API_KEY` *(optional)* – bearer token injected in `Authorization`\n- `DATA_HTTP_HEADERS_JSON` *(optional)* – JSON object string for additional headers\n\nSwitch providers by updating `DATA_PROVIDER`; no code changes required.\n\n## Adding Routes\nUse the data store helpers instead of talking to Firestore directly:\n\n```ts\nimport { ok, bad } from './core-utils';\nimport { createUser } from './entities';\n\napp.post('/api/users', async (c) => {\n  const { name } = await c.req.json<{ name?: string }>();\n  if (!name?.trim()) return bad(c, 'name required');\n  const user = await createUser(c.env, { id: crypto.randomUUID(), name: name.trim() });\n  return ok(c, user);\n});\n```\n\n## Firestore Notes\n- Service account keys should be stored as **secrets** (`wrangler secret put`, Secret Manager) not committed to git.\n- `FIRESTORE_PRIVATE_KEY_B64` must include the full PEM (header + footer) before encoding.\n- Firestore REST API is used; requests are signed and cached per instance.\n- `entities.ts` shows how to seed collections and run CRUD operations.\n\n## Styling & Frontend\n- Keep Tailwind customization in `tailwind.config.js`\n- Prefer provided ShadCN components; use React Query for async data\n- Handle loading/error states in the UI\n\n## Deployment\n- App Engine: `npm run build && gcloud app deploy`\n- Cloudflare Workers: `bun run build && wrangler deploy`\n- Ensure the same environment variables exist in both runtimes for consistent behavior.\n\n## Custom Providers\n- Implement your own HTTPS service that accepts the same payloads (`DataStore` interface).\n- Use `DATA_PROVIDER=http` plus headers/keys to point the template at your service.\n\nThis approach keeps Google Cloud as the default while remaining declarative and flexible for other databases."
    }
  },
  {
    "name": "vite-cfagents-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "@modelcontextprotocol",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "framer-motion",
      "hono",
      "immer",
      "input-otp",
      "mcp-client",
      "mcp-remote",
      "next",
      "openai",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection Guidelines\n\nThis template delivers a production-ready AI chat experience with streaming responses, tool calling, and session persistence backed by Firestore (default) or any HTTPS-accessible datastore. It runs on Google App Engine by default and remains portable to Cloudflare Workers or other hosts through configuration.\n\n* Use this template when you need:\n  * Full-featured AI chat applications with tool/function calling\n  * Multi-model support (Gemini, OpenAI, Claude via gateway URLs)\n  * Persisted chat history, session management, and analytics stored in Firestore\n  * Streaming responses with real-time UI updates\n  * Integration points for Model Context Protocol (MCP) clients or custom tools\n\n* Avoid it for:\n  * Simple static websites without AI capabilities\n  * Chatbots that only require a single Q&A flow without persistence\n  * Projects where you don’t control API keys for AI gateways\n\n* Built with:\n  * Hono-based backend using provider-agnostic datastore helpers (Firestore default, HTTP fallback)\n  * OpenAI SDK compatible with Google Cloud AI Gateway or other gateways\n  * React + Vite frontend with Shadcn/UI, Tailwind, and Framer Motion\n  * Optional MCP client integration via the official TypeScript SDK",
      "usage": "# Usage Instructions\n\n# Usage Instructions\n\nStart customizing the UI in `src/pages/DemoPage.tsx`. The page auto-refreshes with Vite HMR.\n\nThe chat API lives under `/api/chat/:sessionId/*` and is implemented in `worker/userRoutes.ts`. These routes provide:\n- `GET /messages` – load persisted conversation state\n- `POST /chat` – send a message (supports streaming)\n- `POST /model` – switch AI model\n- `DELETE /clear` – reset conversation\n\nSession management endpoints (`/api/sessions/*`) create, list, update, and clear chat sessions backed by Firestore (or any configured datastore).\n\n## Built with\n- React + Vite + Shadcn/UI for the frontend\n- Tailwind CSS and Framer Motion for styling and animations\n- Hono for the backend HTTP router\n- Firestore datastore helpers (default) with HTTP-provider fallback\n- OpenAI SDK compatible with Google Cloud AI Gateway or other multi-model gateways\n- Optional MCP client integration (see `worker/mcp-client.ts`)\n\n## Environment Variables\n- `CF_AI_BASE_URL` – AI gateway base URL (required)\n- `CF_AI_API_KEY` – gateway API key (required)\n- `SERPAPI_KEY` – optional, enables web search tool\n- Firestore defaults (required unless using HTTP provider):\n  - `FIRESTORE_PROJECT_ID`\n  - `FIRESTORE_CLIENT_EMAIL`\n  - `FIRESTORE_PRIVATE_KEY_B64` (base64-encoded PEM)\n  - Optional: `FIRESTORE_DATABASE_ID`, `FIRESTORE_API_ENDPOINT`\n- HTTP provider (optional alternative):\n  - `DATA_PROVIDER=http`\n  - `DATA_HTTP_BASE_URL`\n  - `DATA_HTTP_API_KEY` (optional)\n  - `DATA_HTTP_HEADERS_JSON` (optional JSON for extra headers)\n\nStore secrets securely (App Engine Secret Manager, `wrangler secret`, etc.).\n\n## Restrictions & Best Practices\n- Never expose API keys client-side.\n- Reuse the provided session APIs rather than rolling your own.\n- Validate tool inputs in `worker/tools.ts`; handle errors gracefully.\n- Keep UI responsive and accessible; leverage existing Shadcn components.\n\n## Backend Structure\n- `worker/core-utils.ts` – datastore factory, gateway helpers, response helpers\n- `worker/sessionStore.ts` – CRUD helpers for chat sessions\n- `worker/chat.ts` – AI request/response pipeline (stream + tools)\n- `worker/tools.ts` – tool orchestration, including SerpAPI + MCP\n- `worker/userRoutes.ts` – Hono routes for chat & session APIs\n- `worker/types.ts` – shared TypeScript interfaces\n- `worker/mcp-client.ts` – optional MCP SDK bridge\n\n## Frontend Helpers\n- `src/lib/chat.ts` – chat service for calling backend APIs\n- `src/pages/DemoPage.tsx` – demo UI showing streaming chat, sessions, and model switching\n\n## Styling & Animations\n- Use Tailwind utility classes for layout/spacing.\n- Prefer existing Shadcn components (`@/components/ui/*`).\n- Enhance interactions with Framer Motion (see demo page for patterns).\n\n## MCP Integration (Optional)\n- Add server configs to `worker/mcp-client.ts`.\n- Tools discovered via MCP are automatically exposed to the chat handler.\n\n## Important Notes\n- Firestore persistence is built-in; use it to persist conversations, not mock data.\n- Remind users about AI rate limits (e.g., add a footer note) so expectations are set.\n\nThis template defaults to Google Cloud but remains portable to other environments by switching environment variables. Use the existing APIs to build production-grade AI chat applications quickly.\n\n# Available bindings:\n**Only The following bindings are to be used in the project! Do not use any other bindings or remove/replace any of the bindings**\n- `CHAT_AGENT`: A durable object binding for the chat agent, but can be extended and used for other agentic purposes\n- `APP_CONTROLLER`: A durable object binding for the app controller, but can be extended and used for other agentic purposes\n**IMPORTANT: You are NOT ALLOWED to edit/add/remove ANY worker bindings OR touch wrangler.jsonc/wrangler.toml. Build your application around what is already provided.**\n\n# IMPORTANT NOTE: You must inform the user that although this project has AI capaibilities, There is a limit on the number of requests that can be made to the AI servers across all user apps in a given time period. \nAdd the above note in an appropriate and visible location in the app - like in the footer or in the chat interface or as a modal"
    }
  }
]