[
  {
    "name": "c-code-next-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "critters",
      "date-fns",
      "framer-motion",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "swc",
      "swr",
      "tailwind",
      "typescript",
      "vaul",
      "wrangler",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection Guidelines\n\nThis template offers a streamlined and performant foundation for building beautiful, responsive landing pages with modern animations and iconography.\n\n## Template Constraints\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`.\n- If a change is required, request it instead of editing those files.\n\n* Use this template when you need:\n  * High-performance server-side heavy projects and dashboards\n  * Pages optimized for SEO with server-rendered content\n  * Responsive design with smooth scrolling and page transitions\n  * Easily customizable layouts for product launches, waitlists, or portfolios\n  * Design-first experiences with animation and interactivity\n\n* Do not use it for:\n  * Lightweight, mostly client side heavy projects\n  * Static pages\n\n* Built with:\n  * **Next.js (Page Router)** for hybrid static & server rendering, built-in SEO, and routing\n  * **Tailwind CSS** for rapid UI development with utility-first styling\n  * **Lucide Icons** for sleek, consistent iconography\n  * **Framer Motion** for intuitive, production-ready animations\n  * **TypeScript** and **ESLint** for type safety and code quality",
      "usage": "# Usage instructions\n\nYou can start editing the page by modifying `pages/index.tsx`. The page auto-updates as you edit the file.\n\nAPI routes can be accessed on [http://localhost:3000/api/hello](http://localhost:3000/api/hello). This endpoint can be edited in `pages/api/hello.ts`.\n\nThe `pages/api` directory is mapped to `/api/*`. Files in this directory are treated as API routes instead of React pages.\n\n- Built with:\n  * Next.js (Page Router) for hybrid static/server rendering and SEO optimization\n  * Tailwind CSS** for utility-first styling and rapid prototyping\n  * Lucide Icons** (React) for modern, consistent iconography\n  * Framer Motion** for smooth, production-ready animations\n  * ESLint and TypeScript for linting and type safety out of the box\n  * ShadCN UI** (v2.3.0) for customizable and accessible UI components built on Radix UI primitives\n\n- Restrictions:\n  * When including `tailwind.config.js`, **hardcode custom colors** directly in the config file – do **not** define them in `globals.css` unless specified\n  * Next.js cannot infer props for React Components, so YOU MUST provide default props\n  * Use Page router and not App router\n  * Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`\n  * If a change is required, request it instead of editing those files\n\n- Styling:\n  * Must generate **fully responsive** and accessible layouts\n  * Use Shadcn preinstalled components rather than writing custom ones when possible\n  * Use **Tailwind's spacing, layout, and typography utilities** for all components\n\n- Components:\n  * All Shadcn components are available and can be imported from @/components/ui/...\n  * Do not write custom components if shadcn components are available\n  * Icons from Lucide should be imported directly from `lucide-react`\n\n- Animation:\n  * Use `framer-motion`'s `motion` components to animate sections on scroll or page load\n  * You can integrate variants and transitions using Tailwind utility classes alongside motion props\n\n---\n\nComponents available:\n```sh\n$ ls -1 src/components/ui\naccordion.tsx\nalert-dialog.tsx\nalert.tsx\naspect-ratio.tsx\navatar.tsx\nbadge.tsx\nbreadcrumb.tsx\nbutton.tsx\ncalendar.tsx\ncard.tsx\ncarousel.tsx\nchart.tsx\ncheckbox.tsx\ncollapsible.tsx\ncommand.tsx\ncontext-menu.tsx\ndialog.tsx\ndrawer.tsx\ndropdown-menu.tsx\nform.tsx\nhover-card.tsx\ninput-otp.tsx\ninput.tsx\nlabel.tsx\nmenubar.tsx\nnavigation-menu.tsx\npagination.tsx\npopover.tsx\nprogress.tsx\nradio-group.tsx\nresizable.tsx\nscroll-area.tsx\nselect.tsx\nseparator.tsx\nsheet.tsx\nsidebar.tsx\nskeleton.tsx\nslider.tsx\nsonner.tsx\nswitch.tsx\ntable.tsx\ntabs.tsx\ntextarea.tsx\ntoast.tsx\ntoggle-group.tsx\ntoggle.tsx\ntooltip.tsx\n```\n\n### Usage Example\n\n```tsx file=\"src/components/Hero.tsx\"\n'use client'\n\nimport { motion } from 'framer-motion'\nimport { ArrowRightIcon } from 'lucide-react'\nimport { Button } from '@/components/ui/button'\n\nexport function Hero() {\n  return (\n    <section className=\"w-full bg-white py-20 text-center\">\n      <motion.div \n        initial={{ opacity: 0, y: 30 }} \n        animate={{ opacity: 1, y: 0 }} \n        transition={{ duration: 0.6 }}\n        className=\"mx-auto max-w-2xl px-6\"\n      >\n        <h1 className=\"text-4xl font-bold tracking-tight sm:text-5xl\">\n          Build Stunning Landing Pages Fast\n        </h1>\n        <p className=\"mt-4 text-gray-600\">\n          A modern Next.js starter with Tailwind, Framer Motion, and Lucide.\n        </p>\n        <div className=\"mt-6 flex justify-center\">\n          <Button className=\"inline-flex items-center gap-2 rounded-md bg-black px-6 py-3 text-white hover:bg-gray-900 transition\">\n            Get Started\n            <ArrowRightIcon className=\"size-4\" />\n          </Button>\n        </div>\n      </motion.div>\n    </section>\n  )\n}\n```"
    },
    "supportedProviders": [
      "cloudflare"
    ],
    "deploymentType": "platform-specific"
  },
  {
    "name": "c-code-react-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "framer-motion",
      "hono",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "wrangler",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nModern React SPA starter\n\n## Template Constraints\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`.\n- If a change is required, request it instead of editing those files.\n\nUse when:\n- Client-side only apps with no backend persistence\n- Static apps, dashboards\n- Simple, fast Vite projects\n\nAvoid when:\n- SEO/SSR landing pages\n- Heavy backend/server needs\n- Data persistence of any kind is required on server side\n\nBuilt with:\n- React Router, ShadCN UI, Tailwind, Lucide Icons, ESLint, Vite",
      "usage": "# Usage\n\n## Built with\n- React Router 6, ShadCN UI, Tailwind, Lucide Icons, ESLint, Vite\n- Platform-agnostic backend support (can be deployed to Cloudflare Workers, Google App Engine, or any hosting platform)\n\n## Restrictions\n- Tailwind: define custom colors in `tailwind.config.js` (not in `index.css`)\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`\n- If a change is required, request it instead of editing those files\n\n## Styling\n- Responsive, accessible\n- Prefer ShadCN components; Tailwind utilities for custom parts\n- Icons from `lucide-react`\n- Error boundaries are already implemented\n\n## Animation\n- Use `framer-motion` for small interactions when needed\n\n## Components\n- Import from `@/components/ui/*` (ShadCN). Avoid reinventing components.\n\n## Example\n```tsx\nimport { Button } from '@/components/ui/button'\nimport { Card, CardContent } from '@/components/ui/card'\n\nexport function Example() {\n  return (\n    <Card className=\"max-w-sm\">\n      <CardContent className=\"p-4 flex gap-2\">\n        <Button>Click</Button>\n      </CardContent>\n    </Card>\n  )\n}\n```\n\n## Backend (optional)\n- If you add backend routes, do it in `worker/index.ts` (or your platform's entry point). Follow the existing pattern carefully to avoid breakage.\n- The backend can be deployed to Cloudflare Workers, Google App Engine, or any Node.js-compatible hosting platform."
    },
    "supportedProviders": [
      "cloudflare"
    ],
    "deploymentType": "client-only"
  },
  {
    "name": "next-gcp-client-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "clsx",
      "cmdk",
      "critters",
      "date-fns",
      "framer-motion",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "swc",
      "swr",
      "tailwind",
      "typescript",
      "vaul",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nNext.js frontend-oriented template optimized for Google App Engine with minimal service requirements. Perfect for SEO-optimized landing pages, marketing sites, and content-heavy applications that benefit from server-side rendering but have minimal backend needs.\n\n## Template Constraints\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`.\n- If a change is required, request it instead of editing those files.\n\nUse when:\n- SEO-optimized landing pages and marketing sites\n- Content-heavy websites with server-side rendering\n- Portfolio sites and showcase applications\n- Blogs and documentation sites\n- Applications that need SSR but minimal API functionality\n- Deploying to Google App Engine with cost-effective resource usage\n\nAvoid when:\n- Heavy backend processing or complex API requirements (use full-stack template)\n- Static-only websites (use React/Vite client-only template)\n- You need Cloudflare Workers-specific features\n- Applications requiring extensive database operations\n\nNote: Optimized for Google Cloud Platform (App Engine) with minimal instance requirements. Leverages Next.js SSR capabilities while keeping resource usage low. Can include basic API routes if needed, but optimized for frontend-heavy workloads.\n\nBuilt with:\n- **Next.js (Page Router)** for server-side rendering and SEO optimization\n- **Tailwind CSS** for rapid UI development\n- **Lucide Icons** for consistent iconography\n- **Framer Motion** for animations\n- **TypeScript** and **ESLint** for type safety and code quality",
      "usage": "# Usage instructions\n\nThis is a Next.js frontend-oriented application optimized for Google App Engine with minimal service requirements. Perfect for SEO-optimized sites that benefit from server-side rendering but have minimal backend needs.\n\n## Pages\nYou can start editing pages by modifying files in `src/pages/`. The page auto-updates as you edit the file.\n\n## API Routes (Optional)\nBasic API routes can be accessed at `/api/*`. Files in `src/pages/api/` are treated as API routes.\n\nExample API route: `src/pages/api/hello.ts` → accessible at `/api/hello`\n\nNote: This template is optimized for frontend-heavy workloads. Use API routes sparingly for simple operations only.\n\n## Architecture\n- `src/pages/`: React pages (with SSR support)\n- `src/pages/api/`: Optional basic API endpoints (use minimally)\n- `src/components/`: Reusable UI components\n- `src/lib/`: Utility functions and helpers\n- `src/styles/`: Global styles\n\n## Built with:\n- **Next.js (Page Router)** for hybrid static/server rendering and SEO optimization\n- **Tailwind CSS** for utility-first styling\n- **Lucide Icons** for modern iconography\n- **Framer Motion** for smooth animations\n- **ESLint and TypeScript** for linting and type safety\n- **ShadCN UI** for customizable and accessible UI components\n\n## Restrictions:\n- When including `tailwind.config.js`, **hardcode custom colors** directly in the config file – do **not** define them in `globals.css` unless specified\n- Next.js cannot infer props for React Components, so YOU MUST provide default props\n- Use Page router and not App router\n- Keep API routes minimal - this template is optimized for frontend workloads\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`\n- If a change is required, request it instead of editing those files\n\n## Styling:\n- Must generate **fully responsive** and accessible layouts\n- Use Shadcn preinstalled components rather than writing custom ones when possible\n- Use **Tailwind's spacing, layout, and typography utilities** for all components\n\n## Components:\n- All Shadcn components are available and can be imported from `@/components/ui/...`\n- Do not write custom components if shadcn components are available\n- Icons from Lucide should be imported directly from `lucide-react`\n\n## Server-Side Rendering:\n- Leverage Next.js SSR for SEO optimization\n- Use `getServerSideProps` for dynamic server-rendered content\n- Use `getStaticProps` and `getStaticPaths` for static generation when possible\n- Pages are server-rendered by default for optimal SEO\n\n## Environment Variables:\nSet these in `app.yaml` or via Google Cloud Secret Manager:\n- `NODE_ENV`: Set to `production` for production deployments\n- Add minimal environment variables as needed\n\n## Deployment:\n- **Google App Engine**: `npm run build && gcloud app deploy`\n- The Next.js build output is automatically served by App Engine\n- Optimized for minimal instance usage (F1 instance class, 0-1 instances)\n\n## Performance Optimization:\n- This template is configured for minimal resource usage\n- Use static generation (`getStaticProps`) when possible to reduce server load\n- Keep API routes simple and lightweight\n- Leverage Next.js Image optimization for better performance"
    },
    "supportedProviders": [
      "gcp"
    ],
    "deploymentType": "client-only"
  },
  {
    "name": "next-gcp-fullstack-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "clsx",
      "cmdk",
      "critters",
      "date-fns",
      "framer-motion",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "swc",
      "swr",
      "tailwind",
      "typescript",
      "vaul",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nNext.js full-stack application template optimized for Google App Engine. Perfect for applications that require both server-side rendering and API routes, with database integration and server-side logic.\n\n## Template Constraints\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`.\n- If a change is required, request it instead of editing those files.\n\nUse when:\n- Full-stack applications with API routes\n- Server-side rendering (SSR) requirements\n- Applications needing database connections\n- Dashboards, admin panels, and SaaS applications\n- E-commerce sites with backend processing\n- Applications requiring authentication and authorization\n- Deploying to Google App Engine with Node.js runtime\n\nAvoid when:\n- Static websites or landing pages (use client-only template)\n- You need Cloudflare Workers-specific features\n- You need direct access to Cloudflare bindings (KV, D1, Durable Objects)\n- Lightweight frontend-only projects\n\nNote: Optimized for Google Cloud Platform (App Engine) with Node.js runtime. Supports both server-side rendering and API routes. Can integrate with Firestore, Cloud SQL, or other GCP services.\n\nBuilt with:\n- **Next.js (Page Router)** for hybrid static & server rendering, built-in SEO, and routing\n- **API Routes** for backend functionality\n- **Tailwind CSS** for rapid UI development\n- **Lucide Icons** for consistent iconography\n- **Framer Motion** for animations\n- **TypeScript** and **ESLint** for type safety and code quality",
      "usage": "# Usage instructions\n\nThis is a full-stack Next.js application optimized for Google App Engine. You can start editing pages by modifying files in `src/pages/`.\n\n## API Routes\nAPI routes can be accessed at `/api/*`. Files in `src/pages/api/` are treated as API routes.\n\nExample API route: `src/pages/api/hello.ts` → accessible at `/api/hello`\n\n## Architecture\n- `src/pages/`: React pages and API routes\n- `src/pages/api/`: Backend API endpoints\n- `src/components/`: Reusable UI components\n- `src/lib/`: Utility functions and helpers\n- `src/styles/`: Global styles\n\n## Built with:\n- **Next.js (Page Router)** for hybrid static/server rendering and SEO optimization\n- **API Routes** for backend functionality\n- **Tailwind CSS** for utility-first styling\n- **Lucide Icons** for modern iconography\n- **Framer Motion** for smooth animations\n- **ESLint and TypeScript** for linting and type safety\n- **ShadCN UI** for customizable and accessible UI components\n\n## Restrictions:\n- When including `tailwind.config.js`, **hardcode custom colors** directly in the config file – do **not** define them in `globals.css` unless specified\n- Next.js cannot infer props for React Components, so YOU MUST provide default props\n- Use Page router and not App router\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`\n- If a change is required, request it instead of editing those files\n\n## Styling:\n- Must generate **fully responsive** and accessible layouts\n- Use Shadcn preinstalled components rather than writing custom ones when possible\n- Use **Tailwind's spacing, layout, and typography utilities** for all components\n\n## Components:\n- All Shadcn components are available and can be imported from `@/components/ui/...`\n- Do not write custom components if shadcn components are available\n- Icons from Lucide should be imported directly from `lucide-react`\n\n## API Routes:\n- Create API routes in `src/pages/api/`\n- Use standard Next.js API route handlers\n- Can integrate with Firestore, Cloud SQL, or other GCP services\n- Access environment variables via `process.env`\n\n## Environment Variables:\nSet these in `app.yaml` or via Google Cloud Secret Manager:\n- `NODE_ENV`: Set to `production` for production deployments\n- Add your own variables for database connections, API keys, etc.\n\n## Deployment:\n- **Google App Engine**: `npm run build && gcloud app deploy`\n- The Next.js build output is automatically served by App Engine\n- API routes are handled by the Node.js runtime\n\n## Database Integration:\n- Can integrate with Firestore, Cloud SQL, or any Node.js-compatible database\n- Use environment variables for connection strings and credentials\n- Store sensitive credentials in Google Cloud Secret Manager"
    },
    "supportedProviders": [
      "gcp"
    ],
    "deploymentType": "full-stack"
  },
  {
    "name": "vite-cf-DO-KV-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "framer-motion",
      "hono",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "wrangler",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nFull-stack template with a seeded datastore for multi-entity demos. Ships with Firestore (via REST) as the default provider plus an HTTP fallback, so the same generated backend can deploy to Google App Engine, Cloudflare Workers, or any hosting platform that can supply environment variables.\n\n## Template Constraints\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`.\n- If a change is required, request it instead of editing those files.\n\nUse when:\n- You want built-in seed endpoints to bootstrap demo content\n- The backend needs CRUD APIs plus counters/stateful metrics\n- You prefer Firestore defaults but may swap to another HTTPS provider later\n\nAvoid when:\n- You only need a frontend SPA with no backend\n- SEO/SSR marketing sites (choose Next.js template)\n\nBuilt with:\n- React Router, ShadCN UI, Tailwind, Lucide Icons, ESLint, Vite\n- Hono API + datastore abstraction (Firestore default, HTTP provider optional)",
      "usage": "# Usage\n\n## Overview\nFull-stack React + Hono template with a seeded datastore abstraction. Defaults to Google Cloud Firestore (REST) but can swap to any HTTPS-accessible provider through environment variables.\n- Frontend: React Router 6 + TypeScript + ShadCN UI\n- Backend: Hono APIs using `createDataStore` helpers (Firestore by default, HTTP fallback)\n- Shared: Types in `shared/types.ts`\n- Deployment: Works on Google App Engine, Cloudflare Workers, or any hosting platform that can supply the env vars\n\n## ⚠️ IMPORTANT: Demo Content\n**All demo pages, mock data, and API endpoints exist purely for reference. Replace them with real application logic.**\n- Replace `HomePage.tsx` / `DemoPage.tsx` with production UI\n- Swap out mock data in `shared/mock-data.ts`\n- Update demo API routes in `worker/userRoutes.ts` and `worker/entities.ts`\n\n## Tech Stack\n- React Router 6, ShadCN UI, Tailwind, Lucide, Hono, TypeScript\n\n## Development Guidelines\n- **Tailwind Colors**: Extend `tailwind.config.js`; avoid hardcoding in CSS\n- **Components**: Prefer existing ShadCN components\n- **Icons**: Import from `lucide-react`\n- **Error Handling**: Error boundaries are pre-implemented\n- **Backend Patterns**: Follow `worker/index.ts` + `worker/userRoutes.ts` and rely on datastore helpers\n- **Platform Config**: Keep deployment descriptors (e.g., `wrangler.jsonc`, `app.yaml`) intact unless explicitly required\n- **Protected configs**: Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`. Request changes instead of editing them.\n\n## Code Organization\n\n### Frontend\n- `src/pages/HomePage.tsx` – placeholder landing page\n- `src/pages/DemoPage.tsx` – demo UI for seed data + counters\n- `src/components/ThemeToggle.tsx` – theme switcher\n- `src/hooks/useTheme.ts` – theme management hook\n\n### Backend\n- `worker/index.ts` – backend entrypoint (middleware + router)\n- `worker/userRoutes.ts` – API routes (seed, CRUD, counter)\n- `worker/entities.ts` – datastore helpers (seed logic, CRUD, counters)\n- `worker/core-utils.ts` – datastore factory + response utilities\n- `worker/datastore/*` – Firestore + HTTP provider implementations\n\n### Shared\n- `shared/types.ts` – shared DTOs for API responses\n- `shared/mock-data.ts` – demo seed data\n\n## API Patterns\nUse `createDataStore` helpers instead of platform-specific bindings:\n```ts\nimport { createDataStore, ok, bad } from './core-utils';\n\napp.get('/api/items', async (c) => {\n  const store = createDataStore(c.env);\n  const page = await store.list<Item>('items', { limit: 25 });\n  return ok(c, page);\n});\n\napp.post('/api/items', async (c) => {\n  const payload = (await c.req.json()) as Partial<Item>;\n  if (!payload.name?.trim()) return bad(c, 'name required');\n  const store = createDataStore(c.env);\n  const next = await store.create('items', { ...payload, id: crypto.randomUUID() });\n  return ok(c, next);\n});\n```\n\n## Environment Variables\nConfigure datastore credentials once secrets are provisioned:\n- `FIRESTORE_PROJECT_ID` – GCP project ID\n- `FIRESTORE_CLIENT_EMAIL` – service account email\n- `FIRESTORE_PRIVATE_KEY_B64` – base64 encoded private key (PEM)\n- Optional: `FIRESTORE_DATABASE_ID`, `FIRESTORE_API_ENDPOINT`\n- Switch providers by setting `DATA_PROVIDER=http` and supplying:\n  - `DATA_HTTP_BASE_URL`\n  - `DATA_HTTP_API_KEY` (optional)\n  - `DATA_HTTP_HEADERS_JSON` (optional additional headers)\n\n## Seeding & Counters\n- `/api/seed` triggers `ensureSeed` in `worker/entities.ts`, inserting mock data and a counter record if none exist.\n- Update or remove this endpoint for production once you have real migrations.\n\n## Storage Patterns\n- Use descriptive collection names (`demo-items`, `counters`, etc.) via datastore helpers.\n- Prefer idempotent operations (e.g., upsert) and partial updates (`store.update`) for mutable records.\n\n## Frontend\n- Call `/api/*` endpoints directly\n- Handle loading/error states using shared types"
    },
    "supportedProviders": [
      "cloudflare"
    ],
    "deploymentType": "full-stack"
  },
  {
    "name": "vite-cf-DO-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "framer-motion",
      "hono",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nFull-stack application with server-side state management. Minimal setup that uses a global state store for persistence and stateful features.\n\n## Template Constraints\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`.\n- If a change is required, request it instead of editing those files.\n\nUse when:\n- You need a backend with persistent storage using Firestore (default) or any HTTPS data provider\n- Real-time/stateful services, dashboards, counters\n- Backend-heavy apps requiring persistent state without locking into Cloudflare primitives\n\nAvoid when:\n- Static/SPAs with no backend\n- SEO/SSR landing pages\n- You only need database-like storage across many entities (see Firestore chat runner)\n\nBuilt with:\n- React Router, ShadCN UI, Tailwind, Lucide Icons, ESLint, Vite\n- Platform-agnostic backend powered by a datastore abstraction (Firestore default, HTTP fallback) that can deploy to Google App Engine, Cloudflare Workers, or any hosting platform",
      "usage": "# Usage\n\n## Overview\nFull-stack React application with server-side state management powered by a provider-agnostic datastore abstraction.\n- Frontend: React Router 6 + TypeScript + ShadCN UI\n- Backend: Hono-based API using `createDataStore` (Firestore default, HTTP fallback)\n- Shared: Types in `shared/types.ts`\n- Deployment: Works on Google App Engine, Cloudflare Workers, or any hosting platform\n\n## ⚠️ IMPORTANT: Demo Content\n**All demo pages, mock data, and API endpoints exist only to showcase patterns. Replace them with real application logic.**\n- Replace `HomePage.tsx` and `DemoPage.tsx` with actual pages\n- Remove or adapt mock data in `shared/mock-data.ts`\n- Replace demo API endpoints (`/api/demo`, `/api/counter`) with real functionality backed by your datastore\n\n## Tech Stack\n- React Router 6, ShadCN UI, Tailwind, Lucide, Hono, TypeScript\n\n## Development Guidelines\n- **Tailwind Colors**: Extend `tailwind.config.js`; do not hardcode colors in CSS\n- **Components**: Prefer existing ShadCN components over custom implementations\n- **Icons**: Import from `lucide-react`\n- **Error Handling**: Error boundaries are provided; wire them into your flows\n- **Backend Patterns**: Follow `worker/index.ts` and `worker/userRoutes.ts`, using `createDataStore` for persistence\n- **Platform Config**: Keep deployment descriptors (e.g., `wrangler.jsonc`, `app.yaml`) intact unless absolutely required\n- **Protected configs**: Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`. Request changes instead of editing them.\n\n## Styling\n- Responsive, accessible layouts\n- Use Tailwind for spacing/typography and ShadCN for components\n\n## Code Organization\n\n### Frontend\n- `src/pages/HomePage.tsx` – placeholder landing page\n- `src/pages/DemoPage.tsx` – demo of datastore-backed endpoints\n- `src/components/ThemeToggle.tsx` – theme switcher\n- `src/hooks/useTheme.ts` – theme management hook\n\n### Backend\n- `worker/index.ts` – backend entrypoint (middleware + router wiring)\n- `worker/userRoutes.ts` – API routes; use datastore helpers instead of platform-specific APIs\n- `worker/entities.ts` – demo persistence helpers built on `createDataStore`\n- `worker/core-utils.ts` – datastore factory and response helpers\n- `worker/datastore/*` – Firestore + HTTP provider implementations\n\n### Shared\n- `shared/types.ts` – API/data types\n- `shared/mock-data.ts` – demo-only seed data\n\n## API Patterns\nUse the datastore abstraction rather than platform-specific bindings:\n```ts\nimport { createDataStore, ok, bad } from './core-utils';\n\napp.get('/api/my-data', async (c) => {\n  const store = createDataStore(c.env);\n  const page = await store.list<MyType>('my-data');\n  return ok(c, page.items);\n});\n\napp.post('/api/my-data', async (c) => {\n  const payload = (await c.req.json()) as MyType;\n  if (!payload.name?.trim()) return bad(c, 'name required');\n  const store = createDataStore(c.env);\n  await store.create('my-data', payload, { id: payload.id ?? crypto.randomUUID() });\n  return ok(c, payload);\n});\n```\n\n## Environment Variables\nConfigure datastore credentials via environment variables or secrets:\n- `FIRESTORE_PROJECT_ID` – GCP project ID\n- `FIRESTORE_CLIENT_EMAIL` – service account email\n- `FIRESTORE_PRIVATE_KEY_B64` – base64-encoded private key (PEM)\n- Optional: `FIRESTORE_DATABASE_ID`, `FIRESTORE_API_ENDPOINT`\n- `DATA_PROVIDER` – set to `http` to switch away from Firestore\n- `DATA_HTTP_BASE_URL`, `DATA_HTTP_API_KEY`, `DATA_HTTP_HEADERS_JSON` – configure external HTTPS datastore\n\n## Storage Patterns\n- Use descriptive collection names (`demo-items`, `counters`, etc.)\n- Seed default data through helpers (see `ensureDemoSeed`)\n- Prefer idempotent operations and partial updates via `store.update`\n\n## Frontend\n- Call `/api/*` routes directly\n- Handle loading and error states using shared types"
    },
    "supportedProviders": [
      "cloudflare"
    ],
    "deploymentType": "full-stack"
  },
  {
    "name": "vite-cf-DO-v2-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "framer-motion",
      "hono",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nGeneral-purpose full-stack application template with Google Cloud Firestore as the default data store. The backend exposes a storage abstraction that can point to Firestore or any HTTPS-accessible database (e.g., MongoDB Data API) via environment configuration.\n\n## Template Constraints\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`.\n- If a change is required, request it instead of editing those files.\n\nUse when:\n- Backend-heavy apps with multiple entities and server-side persistence\n- Chats, ecommerce, dashboards\n- Cost-effective persistence\n- General purpose storage for any multi-entity data\n\nAvoid when:\n- Static/SPAs with no backend\n- SEO/SSR landing pages\n- You need direct access to platform-specific features\n\nNote: Defaults to Google Cloud (App Engine + Firestore) but remains platform-agnostic. Swap providers (e.g., MongoDB) by supplying HTTPS credentials via environment variables.\n\nBuilt with:\n- React Router, ShadCN UI, Tailwind, Lucide Icons, ESLint, Vite\n- Backend data layer with pluggable providers (`firestore` by default, `http` proxy for others)\n- Works on Cloudflare Workers, Google App Engine, or any hosting platform that can expose the same environment variables",
      "usage": "# Usage\n\n## Overview\nFull-stack React + Hono starter wired for Google Cloud App Engine with Firestore by default. The backend exposes a pluggable data store so you can swap Firestore for any HTTPS-accessible database (MongoDB Data API, Supabase REST, custom microservice) by flipping environment variables.\n\n- **Frontend**: React Router 6, ShadCN UI, Tailwind, TypeScript\n- **Backend**: Hono API running on Cloudflare Workers or App Engine Node\n- **Storage**: Firestore REST integration (default) + HTTP proxy provider\n- **Shared**: Types in `shared/types.ts`\n\n## Important: Demo Content\nThe bundled pages, mock data, and routes are for reference only.\n- Replace `HomePage.tsx` / `DemoPage.tsx` with real UI\n- Swap out `shared/mock-data.ts` with production data structures\n- Replace demo API routes in `worker/user-routes.ts`\n\n## Architecture\n- `worker/core-utils.ts` & `worker/datastore/*`: storage configuration + provider implementations\n- `worker/entities.ts`: example repositories (users, chats) using the data store abstraction\n- `worker/user-routes.ts`: demo API routes (CRUD + messaging)\n- `src/lib/api-client.ts`: React Query client\n\n## Environment Variables\nSet these before deploying (Cloudflare secrets or App Engine env vars):\n\n### Firestore (default)\n- `DATA_PROVIDER=firestore`\n- `FIRESTORE_PROJECT_ID` – GCP project ID\n- `FIRESTORE_CLIENT_EMAIL` – service-account email\n- `FIRESTORE_PRIVATE_KEY_B64` – base64-encoded PEM private key (entire key file encoded once)\n- `FIRESTORE_DATABASE_ID` *(optional)* – defaults to `(default)`\n- `FIRESTORE_API_ENDPOINT` *(optional)* – override for emulator testing\n\n### HTTP provider (e.g., MongoDB Data API)\nSet `DATA_PROVIDER=http` and supply:\n- `DATA_HTTP_BASE_URL` – HTTPS endpoint exposing CRUD routes\n- `DATA_HTTP_API_KEY` *(optional)* – bearer token injected in `Authorization`\n- `DATA_HTTP_HEADERS_JSON` *(optional)* – JSON object string for additional headers\n\nSwitch providers by updating `DATA_PROVIDER`; no code changes required.\n\n## Adding Routes\nUse the data store helpers instead of talking to Firestore directly:\n\n```ts\nimport { ok, bad } from './core-utils';\nimport { createUser } from './entities';\n\napp.post('/api/users', async (c) => {\n  const { name } = await c.req.json<{ name?: string }>();\n  if (!name?.trim()) return bad(c, 'name required');\n  const user = await createUser(c.env, { id: crypto.randomUUID(), name: name.trim() });\n  return ok(c, user);\n});\n```\n\n## Firestore Notes\n- Service account keys should be stored as **secrets** (`wrangler secret put`, Secret Manager) not committed to git.\n- `FIRESTORE_PRIVATE_KEY_B64` must include the full PEM (header + footer) before encoding.\n- Firestore REST API is used; requests are signed and cached per instance.\n- `entities.ts` shows how to seed collections and run CRUD operations.\n\n## Styling & Frontend\n- Keep Tailwind customization in `tailwind.config.js`\n- Prefer provided ShadCN components; use React Query for async data\n- Handle loading/error states in the UI\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`. Request changes instead of editing them.\n\n### Theme & Color System\n- The template already ships with the standard ShadCN `ThemeProvider` (`src/components/theme-provider.tsx`) and a ready-made mode toggle button. Always keep or reintroduce that toggle in Phase 1 so users can switch themes instantly.\n- Treat **light mode** as the hero experience but ship an equally polished **dark mode** in the same phase. Use Tailwind `dark:` variants, `bg-background`, `text-foreground`, and the CSS variables defined in `globals.css` so colors stay in sync between themes.\n- Never hard-code raw hex colors inside components. Extend the Tailwind config or CSS variables if new semantics are required (e.g., `--brand-primary`, `--brand-muted`) and reference those tokens across both themes.\n- Before completing a phase, manually review every major screen in both modes to ensure contrast ratios, shadows, and gradients remain legible.\n\n## Deployment\n- App Engine: `npm run build && gcloud app deploy`\n- Cloudflare Workers: `bun run build && wrangler deploy`\n- Ensure the same environment variables exist in both runtimes for consistent behavior.\n\n## Custom Providers\n- Implement your own HTTPS service that accepts the same payloads (`DataStore` interface).\n- Use `DATA_PROVIDER=http` plus headers/keys to point the template at your service.\n\nThis approach keeps Google Cloud as the default while remaining declarative and flexible for other databases."
    },
    "supportedProviders": [
      "cloudflare"
    ],
    "deploymentType": "full-stack"
  },
  {
    "name": "vite-cf-DO-v2-runner-gcp",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "clsx",
      "cmdk",
      "date-fns",
      "framer-motion",
      "hono",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nGeneral-purpose full-stack application template optimized for Google Cloud App Engine with Firestore as the default data store. The backend exposes a storage abstraction that can point to Firestore or any HTTPS-accessible database (e.g., MongoDB Data API) via environment configuration.\n\n## Template Constraints\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`.\n- If a change is required, request it instead of editing those files.\n\nUse when:\n- Backend-heavy apps with multiple entities and server-side persistence\n- Chats, ecommerce, dashboards\n- Cost-effective persistence on Google Cloud Platform\n- General purpose storage for any multi-entity data\n- Deploying to Google App Engine (Node.js runtime)\n\nAvoid when:\n- Static/SPAs with no backend\n- SEO/SSR landing pages\n- You need Cloudflare Workers-specific features\n- You need direct access to Cloudflare bindings (KV, D1, Durable Objects)\n\nNote: Optimized for Google Cloud Platform (App Engine + Firestore). Swap data providers (e.g., MongoDB) by supplying HTTPS credentials via environment variables. The server code uses Node.js-compatible exports.\n\nBuilt with:\n- React Router, ShadCN UI, Tailwind, Lucide Icons, ESLint, Vite\n- Backend data layer with pluggable providers (`firestore` by default, `http` proxy for others)\n- Node.js-compatible server exports for Google App Engine deployment\n- Standard Vite build process (no Cloudflare-specific build tools)",
      "usage": "# Usage\n\n## Overview\nFull-stack React + Hono starter optimized for Google Cloud App Engine with Google Cloud Datastore by default. The backend exposes a pluggable data store so you can swap Datastore for Firestore or any HTTPS-accessible database (MongoDB Data API, Supabase REST, custom microservice) by flipping environment variables.\n\n- **Frontend**: React Router 6, ShadCN UI, Tailwind, TypeScript\n- **Backend**: Hono API running on Google App Engine (Node.js runtime)\n- **Storage**: Google Cloud Datastore (default, uses ADC) + Firestore REST + HTTP proxy provider\n- **Shared**: Types in `shared/types.ts`\n- **Deployment Target**: Google App Engine (Node.js 20)\n\n## Important: Demo Content\nThe bundled pages, mock data, and routes are for reference only.\n- Replace `HomePage.tsx` / `DemoPage.tsx` with real UI\n- Swap out `shared/mock-data.ts` with production data structures\n- Replace demo API routes in `worker/user-routes.ts`\n\n## Architecture\n- `worker/core-utils.ts` & `worker/datastore/*`: storage configuration + provider implementations\n- `worker/entities.ts`: example repositories (users, chats) using the data store abstraction\n- `worker/user-routes.ts`: demo API routes (CRUD + messaging)\n- `src/lib/api-client.ts`: React Query client\n\n## Environment Variables\nSet these before deploying (App Engine environment variables or Secret Manager). **Always use fallbacks**: `process.env.X ?? DEFAULT_X`.\n\n### Datastore (default – uses Application Default Credentials)\n- `DATA_PROVIDER=datastore` (or omit – Datastore is default)\n- `GCP_PROJECT_ID` or `GOOGLE_CLOUD_PROJECT` *(optional)* – when running on App Engine, ADC auto-detects the project\n- No service account keys required when deployed to GCP; ADC is used automatically\n\n### Firestore (explicit – requires service account keys)\n- `DATA_PROVIDER=firestore`\n- `FIRESTORE_PROJECT_ID` – GCP project ID\n- `FIRESTORE_CLIENT_EMAIL` – service-account email\n- `FIRESTORE_PRIVATE_KEY_B64` – base64-encoded PEM private key (entire key file encoded once)\n- `FIRESTORE_DATABASE_ID` *(optional)* – defaults to `(default)`\n- `FIRESTORE_API_ENDPOINT` *(optional)* – override for emulator testing\n\n### HTTP provider (e.g., MongoDB Data API)\nSet `DATA_PROVIDER=http` and supply:\n- `DATA_HTTP_BASE_URL` – HTTPS endpoint exposing CRUD routes\n- `DATA_HTTP_API_KEY` *(optional)* – bearer token injected in `Authorization`\n- `DATA_HTTP_HEADERS_JSON` *(optional)* – JSON object string for additional headers\n\nSwitch providers by updating `DATA_PROVIDER`; no code changes required.\n\n## Backend / Worker Imports (Node ESM)\nIn `worker/` and any server-side code, **always use explicit `.js` extensions** in relative imports so Node ESM resolves modules after TypeScript compilation (e.g. `from './user-routes.js'`, `from './core-utils.js'`). Do not use extensionless relative imports in backend code.\n\n## Adding Routes\nUse the data store helpers instead of talking to Datastore/Firestore directly:\n\n```ts\nimport { ok, bad } from './core-utils.js';\nimport { createUser } from './entities.js';\n\napp.post('/api/users', async (c) => {\n  const { name } = await c.req.json<{ name?: string }>();\n  if (!name?.trim()) return bad(c, 'name required');\n  const user = await createUser(c.env, { id: crypto.randomUUID(), name: name.trim() });\n  return ok(c, user);\n});\n```\n\n## Datastore & Firestore Notes\n- **Datastore (default)**: Uses Application Default Credentials (ADC) when running on GCP. No service account keys needed for App Engine deployments.\n- **Firestore**: When `DATA_PROVIDER=firestore`, service account keys must be provided. Store keys as **secrets** (Google Cloud Secret Manager) not committed to git.\n- `FIRESTORE_PRIVATE_KEY_B64` must include the full PEM (header + footer) before encoding.\n- `entities.ts` shows how to seed collections and run CRUD operations.\n- Configure secrets in App Engine: `gcloud app deploy --update-secrets`\n\n## Styling & Frontend\n- Keep Tailwind customization in `tailwind.config.js`\n- Prefer provided ShadCN components; use React Query for async data\n- Handle loading/error states in the UI\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`. Request changes instead of editing them.\n\n### Theme & Color System\n- `src/components/theme-provider.tsx` and the bundled mode toggle (in the navbar layout) already handle light/dark switching—reuse them whenever you restructure the shell. If you remove the stock header, add an obvious toggle back in Phase 1.\n- Light mode is the primary spec, but dark mode must ship simultaneously. Use Tailwind `dark:` modifiers and the CSS variables (`--background`, `--foreground`, etc.) defined in `src/styles/globals.css` so both themes stay synchronized.\n- Avoid hard-coded text/background colors inside components. Introduce semantic tokens (e.g., `--brand-primary`, `--surface-muted`) through Tailwind or CSS variables and apply them consistently across both themes.\n- QA every scene (landing, dashboard, bookings, settings) in both modes before completing a phase to catch low-contrast or washed-out states early.\n\n## Deployment\n- **Google App Engine**: `npm run build && gcloud app deploy`\n- Ensure environment variables are configured in `app.yaml` or via Secret Manager\n- The server exports the Hono app for Node.js runtime compatibility\n\n## Custom Providers\n- Implement your own HTTPS service that accepts the same payloads (`DataStore` interface).\n- Use `DATA_PROVIDER=http` plus headers/keys to point the template at your service.\n\nThis approach keeps Google Cloud as the default while remaining declarative and flexible for other databases."
    },
    "supportedProviders": [
      "gcp"
    ],
    "deploymentType": "full-stack"
  },
  {
    "name": "vite-cfagents-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "@modelcontextprotocol",
      "autoprefixer",
      "class-variance-authority",
      "cloudflare",
      "clsx",
      "cmdk",
      "date-fns",
      "framer-motion",
      "hono",
      "immer",
      "input-otp",
      "mcp-client",
      "mcp-remote",
      "next",
      "openai",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection Guidelines\n\nThis template delivers a production-ready AI chat experience with streaming responses, tool calling, and session persistence backed by Firestore (default) or any HTTPS-accessible datastore. It runs on Google App Engine by default and remains portable to Cloudflare Workers or other hosts through configuration.\n\n## Template Constraints\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`.\n- If a change is required, request it instead of editing those files.\n\n* Use this template when you need:\n  * Full-featured AI chat applications with tool/function calling\n  * Multi-model support (Gemini, OpenAI, Claude via gateway URLs)\n  * Persisted chat history, session management, and analytics stored in Firestore\n  * Streaming responses with real-time UI updates\n  * Integration points for Model Context Protocol (MCP) clients or custom tools\n\n* Avoid it for:\n  * Simple static websites without AI capabilities\n  * Chatbots that only require a single Q&A flow without persistence\n  * Projects where you don’t control API keys for AI gateways\n\n* Built with:\n  * Hono-based backend using provider-agnostic datastore helpers (Firestore default, HTTP fallback)\n  * OpenAI SDK compatible with Google Cloud AI Gateway or other gateways\n  * React + Vite frontend with Shadcn/UI, Tailwind, and Framer Motion\n  * Optional MCP client integration via the official TypeScript SDK",
      "usage": "# Usage Instructions\n\n# Usage Instructions\n\nStart customizing the UI in `src/pages/DemoPage.tsx`. The page auto-refreshes with Vite HMR.\n\nThe chat API lives under `/api/chat/:sessionId/*` and is implemented in `worker/userRoutes.ts`. These routes provide:\n- `GET /messages` – load persisted conversation state\n- `POST /chat` – send a message (supports streaming)\n- `POST /model` – switch AI model\n- `DELETE /clear` – reset conversation\n\nSession management endpoints (`/api/sessions/*`) create, list, update, and clear chat sessions backed by Firestore (or any configured datastore).\n\n## Built with\n- React + Vite + Shadcn/UI for the frontend\n- Tailwind CSS and Framer Motion for styling and animations\n- Hono for the backend HTTP router\n- Firestore datastore helpers (default) with HTTP-provider fallback\n- OpenAI SDK compatible with Google Cloud AI Gateway or other multi-model gateways\n- Optional MCP client integration (see `worker/mcp-client.ts`)\n\n## Environment Variables\n- `CF_AI_BASE_URL` – AI gateway base URL (required)\n- `CF_AI_API_KEY` – gateway API key (required)\n- `SERPAPI_KEY` – optional, enables web search tool\n- Firestore defaults (required unless using HTTP provider):\n  - `FIRESTORE_PROJECT_ID`\n  - `FIRESTORE_CLIENT_EMAIL`\n  - `FIRESTORE_PRIVATE_KEY_B64` (base64-encoded PEM)\n  - Optional: `FIRESTORE_DATABASE_ID`, `FIRESTORE_API_ENDPOINT`\n- HTTP provider (optional alternative):\n  - `DATA_PROVIDER=http`\n  - `DATA_HTTP_BASE_URL`\n  - `DATA_HTTP_API_KEY` (optional)\n  - `DATA_HTTP_HEADERS_JSON` (optional JSON for extra headers)\n\nStore secrets securely (App Engine Secret Manager, `wrangler secret`, etc.).\n\n## Restrictions & Best Practices\n- Never expose API keys client-side.\n- Reuse the provided session APIs rather than rolling your own.\n- Validate tool inputs in `worker/tools.ts`; handle errors gracefully.\n- Keep UI responsive and accessible; leverage existing Shadcn components.\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`. Request changes instead of editing them.\n\n## Backend Structure\n- `worker/core-utils.ts` – datastore factory, gateway helpers, response helpers\n- `worker/sessionStore.ts` – CRUD helpers for chat sessions\n- `worker/chat.ts` – AI request/response pipeline (stream + tools)\n- `worker/tools.ts` – tool orchestration, including SerpAPI + MCP\n- `worker/userRoutes.ts` – Hono routes for chat & session APIs\n- `worker/types.ts` – shared TypeScript interfaces\n- `worker/mcp-client.ts` – optional MCP SDK bridge\n\n## Frontend Helpers\n- `src/lib/chat.ts` – chat service for calling backend APIs\n- `src/pages/DemoPage.tsx` – demo UI showing streaming chat, sessions, and model switching\n\n## Styling & Animations\n- Use Tailwind utility classes for layout/spacing.\n- Prefer existing Shadcn components (`@/components/ui/*`).\n- Enhance interactions with Framer Motion (see demo page for patterns).\n\n## MCP Integration (Optional)\n- Add server configs to `worker/mcp-client.ts`.\n- Tools discovered via MCP are automatically exposed to the chat handler.\n\n## Important Notes\n- Firestore persistence is built-in; use it to persist conversations, not mock data.\n- Remind users about AI rate limits (e.g., add a footer note) so expectations are set.\n\nThis template defaults to Google Cloud but remains portable to other environments by switching environment variables. Use the existing APIs to build production-grade AI chat applications quickly.\n\n# Available bindings:\n**Only The following bindings are to be used in the project! Do not use any other bindings or remove/replace any of the bindings**\n- `CHAT_AGENT`: A durable object binding for the chat agent, but can be extended and used for other agentic purposes\n- `APP_CONTROLLER`: A durable object binding for the app controller, but can be extended and used for other agentic purposes\n**IMPORTANT: You are NOT ALLOWED to edit/add/remove ANY worker bindings OR touch wrangler.jsonc/wrangler.toml. Build your application around what is already provided.**\n\n# IMPORTANT NOTE: You must inform the user that although this project has AI capaibilities, There is a limit on the number of requests that can be made to the AI servers across all user apps in a given time period. \nAdd the above note in an appropriate and visible location in the app - like in the footer or in the chat interface or as a modal"
    },
    "supportedProviders": [
      "cloudflare"
    ],
    "deploymentType": "full-stack"
  },
  {
    "name": "vite-gcp-client-only-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "clsx",
      "cmdk",
      "date-fns",
      "framer-motion",
      "hono",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nReact/Vite frontend-only template optimized for Google App Engine static hosting. Perfect for single-page applications, landing pages, portfolios, and marketing sites that don't require server-side logic.\n\n## Template Constraints\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`.\n- If a change is required, request it instead of editing those files.\n\nUse when:\n- Static websites and SPAs (Single Page Applications)\n- Landing pages, portfolios, marketing sites\n- Brochure websites and waitlist pages\n- Client-side only applications with no backend requirements\n- Deploying to Google App Engine with minimal resource usage\n\nAvoid when:\n- You need server-side API routes or backend logic\n- You require server-side rendering (SSR)\n- You need database connections or server-side data processing\n- You need Cloudflare Workers-specific features\n\nNote: Optimized for Google Cloud Platform (App Engine) with static file serving. The template builds a production-ready static site that can be served efficiently from App Engine.\n\nBuilt with:\n- React Router, ShadCN UI, Tailwind, Lucide Icons, ESLint, Vite\n- Static file serving via Google App Engine\n- Standard Vite build process (no Cloudflare-specific build tools)\n- Emits production assets to `dist/client/**` (required by App Engine preview/deploy)\n- TypeScript for type safety",
      "usage": "# Usage\n\n## Overview\nFrontend-only React + Vite starter optimized for Google App Engine static hosting. This template is perfect for building static websites, landing pages, and SPAs that don't require backend functionality.\n\n- **Frontend**: React Router 6, ShadCN UI, Tailwind, TypeScript\n- **Build**: Vite for fast development and optimized production builds\n- **Deployment Target**: Google App Engine (static file serving)\n\n## Important: Demo Content\nThe bundled pages and routes are for reference only.\n- Replace `HomePage.tsx` with your actual UI\n- Customize components in `src/components/`\n- Update routing in `src/main.tsx` if needed\n\n## Architecture\n- `src/`: Frontend React application\n- `src/pages/`: Page components\n- `src/components/`: Reusable UI components\n- `src/lib/`: Utility functions and helpers\n- `public/`: Static assets\n\n## Development\n```bash\nnpm run dev      # Start development server\nnpm run build    # Build for production\nnpm run preview  # Preview production build\n```\n\n## Styling & Frontend\n- Keep Tailwind customization in `tailwind.config.js`\n- Prefer provided ShadCN components\n- Handle loading/error states in the UI\n- Use React Router for client-side navigation\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`. Request changes instead of editing them.\n\n### Theme & Color System\n- Theme toggle is available in the layout\n- Light mode is the primary spec, but dark mode must ship simultaneously\n- Use Tailwind `dark:` modifiers and CSS variables defined in `src/index.css`\n- Avoid hard-coded text/background colors inside components\n\n## Deployment\n- **Google App Engine**: `npm run build && gcloud app deploy`\n- The build output (`dist/client/`) is served as static files—do **not** change the Vite `build.outDir`\n- No server-side code is required or deployed\n\n## Static File Serving\nApp Engine serves the built static files from `dist/client/`:\n- `index.html` is served for all routes (SPA routing)\n- All assets (JS, CSS, images) are served with appropriate caching headers\n- The `app.yaml` configuration handles routing for client-side navigation"
    },
    "supportedProviders": [
      "gcp"
    ],
    "deploymentType": "client-only"
  },
  {
    "name": "vite-gcp-fullstack-runner",
    "language": "typescript",
    "frameworks": [
      "@dnd-kit",
      "@hookform/resolvers",
      "autoprefixer",
      "class-variance-authority",
      "clsx",
      "cmdk",
      "date-fns",
      "framer-motion",
      "hono",
      "immer",
      "input-otp",
      "next",
      "postcss",
      "react",
      "recharts",
      "sonner",
      "tailwind",
      "tw-animate-css",
      "typescript",
      "vaul",
      "vite",
      "zod",
      "zustand"
    ],
    "description": {
      "selection": "# Template Selection\n\nGeneral-purpose full-stack application template optimized for Google Cloud App Engine with Google Cloud Datastore as the default data store (uses ADC on App Engine). The backend exposes a storage abstraction that can point to Datastore, Firestore, or any HTTPS-accessible database via environment configuration.\n\n## Template Constraints\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`.\n- If a change is required, request it instead of editing those files.\n\nUse when:\n- Backend-heavy apps with multiple entities and server-side persistence\n- Chats, ecommerce, dashboards\n- Cost-effective persistence on Google Cloud Platform\n- General purpose storage for any multi-entity data\n- Deploying to Google App Engine (Node.js runtime)\n\nAvoid when:\n- Static/SPAs with no backend\n- SEO/SSR landing pages\n- You need Cloudflare Workers-specific features\n- You need direct access to Cloudflare bindings (KV, D1, Durable Objects)\n\nNote: Optimized for Google Cloud Platform (App Engine + Datastore). Swap data providers (e.g., Firestore, MongoDB) by supplying credentials via environment variables. The server code uses Node.js-compatible exports.\n\nBuilt with:\n- React Router, ShadCN UI, Tailwind, Lucide Icons, ESLint, Vite\n- Backend data layer with pluggable providers (`datastore` by default, uses ADC on App Engine)\n- Node.js-compatible server exports for Google App Engine deployment\n- Standard Vite build process (no Cloudflare-specific build tools)\n- Emits frontend assets to `dist/client/**` (required by App Engine preview/deploy)",
      "usage": "# Usage\n\n## Overview\nFull-stack React + Hono starter optimized for Google Cloud App Engine with Google Cloud Datastore by default. The backend exposes a pluggable data store so you can swap Datastore for Firestore or any HTTPS-accessible database (MongoDB Data API, Supabase REST, custom microservice) by flipping environment variables.\n\n- **Frontend**: React Router 6, ShadCN UI, Tailwind, TypeScript\n- **Backend**: Hono API running on Google App Engine (Node.js runtime)\n- **Storage**: Google Cloud Datastore (default, uses ADC) + Firestore REST + HTTP proxy provider\n- **Shared**: Types in `shared/types.ts`\n- **Deployment Target**: Google App Engine (Node.js 20)\n\n## Important: Demo Content\nThe bundled pages, mock data, and routes are for reference only.\n- Replace `HomePage.tsx` / `DemoPage.tsx` with real UI\n- Swap out `shared/mock-data.ts` with production data structures\n- Replace demo API routes in `worker/user-routes.ts`\n\n## Architecture\n- `worker/core-utils.ts` & `worker/datastore/*`: storage configuration + provider implementations\n- `worker/entities.ts`: example repositories (users, chats) using the data store abstraction\n- `worker/user-routes.ts`: demo API routes (CRUD + messaging)\n- `src/lib/api-client.ts`: React Query client\n\n## Environment Variables\nSet these before deploying (App Engine environment variables or Secret Manager). **Always use fallbacks**: `process.env.X ?? DEFAULT_X`.\n\n### Datastore (default – uses Application Default Credentials)\n- `DATA_PROVIDER=datastore` (or omit – Datastore is default)\n- `GCP_PROJECT_ID` or `GOOGLE_CLOUD_PROJECT` *(optional)* – when running on App Engine, ADC auto-detects the project\n- No service account keys required when deployed to GCP; ADC is used automatically\n\n### Firestore (explicit – requires service account keys)\n- `DATA_PROVIDER=firestore`\n- `FIRESTORE_PROJECT_ID` – GCP project ID\n- `FIRESTORE_CLIENT_EMAIL` – service-account email\n- `FIRESTORE_PRIVATE_KEY_B64` – base64-encoded PEM private key (entire key file encoded once)\n- `FIRESTORE_DATABASE_ID` *(optional)* – defaults to `(default)`\n- `FIRESTORE_API_ENDPOINT` *(optional)* – override for emulator testing\n\n### HTTP provider (e.g., MongoDB Data API)\nSet `DATA_PROVIDER=http` and supply:\n- `DATA_HTTP_BASE_URL` – HTTPS endpoint exposing CRUD routes\n- `DATA_HTTP_API_KEY` *(optional)* – bearer token injected in `Authorization`\n- `DATA_HTTP_HEADERS_JSON` *(optional)* – JSON object string for additional headers\n\nSwitch providers by updating `DATA_PROVIDER`; no code changes required.\n\n## Backend / Worker Imports (Node ESM)\nIn `worker/` and any server-side code, **always use explicit `.js` extensions** in relative imports so Node ESM resolves modules after TypeScript compilation (e.g. `from './user-routes.js'`, `from './core-utils.js'`). Do not use extensionless relative imports in backend code.\n\n## Adding Routes\nUse the data store helpers instead of talking to Datastore/Firestore directly:\n\n```ts\nimport { ok, bad } from './core-utils.js';\nimport { createUser } from './entities.js';\n\napp.post('/api/users', async (c) => {\n  const { name } = await c.req.json<{ name?: string }>();\n  if (!name?.trim()) return bad(c, 'name required');\n  const user = await createUser(c.env, { id: crypto.randomUUID(), name: name.trim() });\n  return ok(c, user);\n});\n```\n\n## Datastore & Firestore Notes\n- **Datastore (default)**: Uses Application Default Credentials (ADC) when running on GCP. No service account keys needed for App Engine deployments.\n- **Firestore**: When `DATA_PROVIDER=firestore`, service account keys must be provided. Store keys as **secrets** (Google Cloud Secret Manager) not committed to git.\n- `FIRESTORE_PRIVATE_KEY_B64` must include the full PEM (header + footer) before encoding.\n- `entities.ts` shows how to seed collections and run CRUD operations.\n- Configure secrets in App Engine: `gcloud app deploy --update-secrets`\n\n## Styling & Frontend\n- Keep Tailwind customization in `tailwind.config.js`\n- Prefer provided ShadCN components; use React Query for async data\n- Handle loading/error states in the UI\n- Do not modify template-owned config files like `vite.config.ts` or `tsconfig*.json`. Request changes instead of editing them.\n\n### Theme & Color System\n- `src/components/theme-provider.tsx` and the bundled mode toggle (in the navbar layout) already handle light/dark switching—reuse them whenever you restructure the shell. If you remove the stock header, add an obvious toggle back in Phase 1.\n- Light mode is the primary spec, but dark mode must ship simultaneously. Use Tailwind `dark:` modifiers and the CSS variables (`--background`, `--foreground`, etc.) defined in `src/styles/globals.css` so both themes stay synchronized.\n- Avoid hard-coded text/background colors inside components. Introduce semantic tokens (e.g., `--brand-primary`, `--surface-muted`) through Tailwind or CSS variables and apply them consistently across both themes.\n- QA every scene (landing, dashboard, bookings, settings) in both modes before completing a phase to catch low-contrast or washed-out states early.\n\n## Deployment\n- **Google App Engine**: `npm run build && gcloud app deploy`\n- Frontend build artifacts are always emitted to `dist/client/**`—do not change the Vite `build.outDir`\n- Ensure environment variables are configured in `app.yaml` or via Secret Manager\n- The server exports the Hono app for Node.js runtime compatibility\n\n## Custom Providers\n- Implement your own HTTPS service that accepts the same payloads (`DataStore` interface).\n- Use `DATA_PROVIDER=http` plus headers/keys to point the template at your service.\n\nThis approach keeps Google Cloud as the default while remaining declarative and flexible for other databases."
    },
    "supportedProviders": [
      "gcp"
    ],
    "deploymentType": "full-stack"
  }
]